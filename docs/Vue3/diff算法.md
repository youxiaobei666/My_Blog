# diff 算法介绍

对比差异的过程叫 diff（difference）

代码中先调用\_render 函数得到虚拟 dom 根节点，然后传入\_update 函数中，在将 updateComponent 传入 Watcher 中，watcher 可以监听函数执行的过程，监测函数执行期间用到了哪些响应式数据并且进行依赖收集

## 什么时候触发 diff 算法

### 触发场景一

一组 DOM 更新

```html
<ul>
  <li>1</li>
  <li>2</li>
  <li>3</li>
</ul>
```

li 标签的 type === 'li'

其中一点个小 li 元素修改了，或者添加了一个小 li 元素

### 场景二

新建组件时，也是会触发 `update` 函数的

## 借助的函数

vue 在内部通过一个叫 `patch` (对比)的函数完成该过程

## 如何判断是否为同一个节点

**在判断两个节点是否相同时，vue 是通过虚拟节点的 `key` 和 `tag`（type 标签类型） 来进行判断的**

**key:**

key 是一个节点的唯一标识，一般不采用 index 作为 key, 一般采用 id

**type/tag:**

:::tip

- div 节点 -> div
- li 节点 -> li
- 注释节点 -> comment
- 组件节点 -> Component 对象实例

:::

## 具体实现

:::tip
在对比节点数组时，Vue 会使用 `数组头指针`，和 `数组尾指针` 向中间靠拢，对比子节点是否相同，相同则保留（节点复用），key 不同的话需要移动到合适的位置。实在没有的话，才能新建。同时，旧的节点没有对应上的，会被销毁。对比完成后，才会去操作真实的 DOM。
:::

**最长递增子序列：**

1. 解释：

> 在计算机科学中，最长递增子序列（longest increasing subsequence）问题是指，在一个给定的数值序列中，找到一个子序列，使得这个子序列元素的数值依次递增，并且这个子序列的长度尽可能地大。最长递增子序列中的元素在原序列中不一定是连续的。许多与数学、算法、随机矩阵理论、表示论相关的研究都会涉及最长递增子序列。解决最长递增子序列问题的算法最低要求 O(n log n)的时间复杂度，这里 n 表示输入序列的规模。

2. 例子

对于以下的原始序列

0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15

最长递增子序列为

0, 2, 6, 9, 11, 15.

值得注意的是原始序列的最长递增子序列并不一定唯一，对于该原始序列，实际上还有以下三个最长递增子序列

0, 4, 6, 9, 11, 15

0, 4, 6, 9, 13, 15

0, 2, 6, 9, 13, 15

3. 目的：

减少移动的次数
